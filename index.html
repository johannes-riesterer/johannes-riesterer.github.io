<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Büro Zwei - Laboratory by johannes-riesterer</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Büro Zwei Labs</h1>
        <h2></h2>
        <a href="https://github.com/johannes-riesterer" class="button"><small>Follow me on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <p>In order to continuously improve my skills and to stay up to date i code small programs which are presented here.
          </p>
        <p> Enjoy!</p>

<p></p>
<h2>Unity3d</h2>
 <a href= "http://buerozwei.com/webdigger/webdigger.html" Here </a> is a small unity3d demo....
![Image of Unity demo](http://buerozwei.com/wp-content/uploads/2015/01/webdigger.png)

<h2>Discrete geometry</h2>
<iframe src="//player.vimeo.com/video/93247178?title=0&amp;byline=0&amp;portrait=0" width="536" height="302" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p>
The main task of discrete geometry is to transfer concepts of differential geometry, where everything is  assumed to be differentiable,  to the world of computer graphics, where everything is highly non differentiable. 
Many modern and fast algorithms make use of these concepts. In the video you can see meshes colored according to their discrete gaussian curvature. For more details see <a href="https://en.wikipedia.org/wiki/Gaussian_curvature" title="curvature">Wikipedia</a>.
</p>
<p>
 Go to    
  <a href="https://github.com/johannes-riesterer/Curvature">project page</a>
 </p>

 <h2>Realtime simulation</h2>
 <p>
Physical simulation of rigid bodies has a long history in computer science. There are a lot of different approaches and it has many applications in the fields of robotics, virtual reality and in the entertainment industry.
</p>
 <h3>Position based methods</h3>
 <iframe src="//player.vimeo.com/video/103111569?title=0&amp;byline=0&amp;portrait=0" width="536" height="302" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
 <p>
 This is a so called position based approach to simulate softbodies. From the mathematical point of view the results are quite inaccurate
 but the visible result still looks plausible.
 </p>
 <p>
 Go to    
  <a href="https://github.com/johannes-riesterer/Verdriller">project page</a>
 </p>
 <h3>Impulse based methods</h3>
 <iframe src="//player.vimeo.com/video/94521511?title=0&amp;byline=0&amp;portrait=0" width="536" height="302" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<iframe src="//player.vimeo.com/video/92245499?title=0&amp;byline=0&amp;portrait=0" width="536" height="302" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<iframe src="//player.vimeo.com/video/85595783?title=0&amp;byline=0&amp;portrait=0" width="536" height="335" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p> Sourcecode is a bit too messy at the moment. Will upload it as soon as it is cleaned up....
</p>



<h2>Finite element programming/analysis</h2>
The finite element method is a technique to approximate the solution of a  partial differential equation on a computer. Partial differential equations are  used to describe 
processes appearing in physics,  engineering,  economics or biology.
See also <a href="https://en.wikipedia.org/wiki/Finite_element_method">Wikipedia</a> for more details.
<p>
</p>
<p>
The mother of all finite element programs written in python using scipy and matplotlib.
Mother of all finite element programs referes to the fact that this program is the blueprint for any finite element program. 

<p> A coarse mesh:</p>
<img src="https://raw.githubusercontent.com/johannes-riesterer/fem_triptychon/master/fem_triptychon_1.png">
<p>Refined mesh:</p>
<img src="https://raw.githubusercontent.com/johannes-riesterer/fem_triptychon/master/fem_triptychon_4.png">
</p>
<p>
Go to    
  <a href="https://github.com/johannes-riesterer/fem_triptychon">project page</a>
 </p>
 
<p> 
Here you can see how two waves behave in a square-shaped area. 
It is coded in the deal.ii framework.
<iframe src="//player.vimeo.com/video/93239393?title=0&amp;byline=0&amp;portrait=0" width="536" height="302" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
</p>
<p>
Go to    
  <a href="https://github.com/johannes-riesterer/WaveEquation_deal.II">project page</a>
 </p>

<h2>A journey through the Hopf fibration</h2>
<iframe src="//player.vimeo.com/video/87388395?title=0&amp;byline=0&amp;portrait=0" width="536" height="336" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p>
Basically the Hopf fibration is a continuous map from the three dimensional sphere to the two dimensional sphere. The two dimensional sphere lives in three dimensions and looks like the surface  of a football while the three dimensional sphere is hard to imaging since it lives in four dimensions. The map was discovered by the mathematician Heinz Hopf. He proved that this map is significantly different from the trivial map which maps everything to a single point. Moreover he demonstrated with the help of this map that the three dimensional sphere locally looks like  the union of twisted circles which is called the Hopf fibration.  The video is a visualization of this fibration and thus  of the three dimensional sphere. For more details see <a href="http://en.wikipedia.org/wiki/Hopf_fibration" title="hopf" target="_blank">wikipedia</a>.
</p>
Go to    
  <a href="https://github.com/johannes-riesterer/HopfFibration_WebGL">project page</a>
 </p>



<h2>Different shaders applied to Tori</h2>
<p>
Shaders are small programs which run directly on the graphic card (gpu).
</p>

<iframe src="//player.vimeo.com/video/91934591?title=0&amp;byline=0&amp;portrait=0" width="536" height="302" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
 <p>
 Go to    
  <a href="https://github.com/johannes-riesterer/SimpleShaderPair">project page</a>
 </p>


<iframe src="//player.vimeo.com/video/87388098?title=0&amp;byline=0&amp;portrait=0" width="536" height="335" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p>
 Go to    
  <a href="https://github.com/johannes-riesterer/TorusShader_WebGL">project page</a>
 </p>

<h2>Fun(ky) with the Raspberry Pi</h2>
<iframe src="//player.vimeo.com/video/82880379?title=0&amp;byline=0&amp;portrait=0" width="536" height="300" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p>
</p>

<h2>Realtime raytracing on the GPU</h2>
<iframe src="//player.vimeo.com/video/87389051?title=0&amp;byline=0&amp;portrait=0" width="536" height="336" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p>
Raytracing is a technique to generate photorealistic images and it is also often used for medical imaging. A detailed description can be found at <a href="http://en.wikipedia.org/wiki/Ray_tracing_(graphics)" title="wikipedia">wikipedia</a>. However it requires considerable processing power. On the other hand it can be parallelized very easily. Since today's graphic cards and in particular their graphics processing units (gpu's) are designed in a highly parallel manner, it is possible to generate realtime animations with this technique. The main problem here is to compute the intersection between  rays and the objects of the scene. Instead of exactly calculating these intersections, one can  approximate them by an algorithm called raymarching with distancebounds. In many cases this  is faster but it also may produce artefacts.
</p>
 <p>
 Go to    
  <a href="https://github.com/IMAGINARY/WebGLSurfer">project page</a>
 </p>




        </section>

        <aside id="sidebar">


          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
